## 常用命令

grep: Global search Regular Expression and Print out the line. 用正则表达式搜索文本，并把匹配的行打印出来。`-v` 反转查找；`-i` 忽略大小写；`-o` 只输出匹配到的部分，而不是整行；`-r` 递归处理目录；`-n` 显示行号；`-e` 多个匹配样式；`-f ,` 若干个样式以行记录在文件中；`-A, -B, -C n` 同时输出之后、之前、前后 n 行。

awk: 

sed: 

date: 输出时间

cal: 日历

bc: 简易计算器。`scale=n` 设置显示小数位数，默认显示整数

man: `man -f ,`，`whatis ,`；`man -k ,`，`apropos ,`

chown, chgrp, chmod

pwd: 显示当前路径；`-P` 显示真实路径，而非链接路径

mkdir: 创建目录；`-m ddd` 手动设置权限；`-p` 递归创建多层目录

**可执行文件搜索路径：**`$PATH`，以 `:` 分隔目录

### 文件与目录管理

cp, rm, mv: 复制、删除与移动

basename, dirname: 文件名与目录名

cat, tac, nl: 输出文档全部内容

more, less: 翻页读取文档

head, tail: 截取若干行

od: 可读取二进制文件

touch: 修改文件时间或创建新文件。`ls --time=[atime, ctime, mtime]`，分别表示最新访问时间、最新状态修改时间、最新内容修改时间。默认修改所有时间，显然 ctime 无法控制。

umask: 查看与设置目录默认属性，数值表示拿掉的权限值，文件默认不带 x。

lsattr, chattr: 查看与设置文件的*隐藏属性*

Set UID, Set GID, Sticky Bit: 文件特殊权限，Todo 补充

file: 查看文件类型

which, type: 从 $PATH 查找可执行文件位置

whereis, locate/updatedb, find: 查找文件

#### 磁盘与文件系统管理

blkid (sudo): 查看目前系统内被格式化的设备，`nvme` 为固态硬盘常用总线接口

dumpe2fs: 查看 ext 家族文件系统的内容。`dumpe2fs [-bh] 设备文件名`，`-h` 只列出 superblock 的数据。

ls -i: 查看文件的 inode 号码。每个目录的大小一般是 block 大小的整数倍！

目录树读取：从目录 block 得到文件的 inode（需要 r 与 x 权限)；从 inode table 得到相应文件的 blocks。对于机械硬盘，需要磁头来回移动，所以分区的规划并不是越大越好。

新增文件：需要 w 与 x 权限；从 bitmap 找到未使用的 inode 和 block 号码，使用之；更新 bitmap 和 superblock。处理数据不一致（写入时停电等突发状况）的处理方案——日志式文件系统：记录预备信息；写入；记录写入完成。

```bash
ls -l /lib/modules/$(uname -r)/kernel/fs # 查看系统支持的文件系统
cat /proc/filesystems # 查看已载入到内存中的支持的文件系统
```

df -T path: 查看挂载点对应的文件系统（分区）

xfs_info: 查看 xfs 文件系统的内容。

df: 列出文件系统的整体磁盘使用量。-a 列出所有文件系统；-m 以 MB 为单位，默认为 KB；-h 自动选择单位；-H 千进制；-T 同时输出文件系统名称；-i 以 inode 数量为单位。主要从 superblock 读取信息。

du: 

## C++ 开发

**函数库**

`cmath` 的特殊性：在 Windows 下，`cmath` 是标准库的一部分，但是在 Linux 下是单列的，缺省不连接。所以使用时需要显式链接，因为库文件是 `libm`，所以应使用 `g++ -lm main.cpp`。

随机数库：`stdlib` 中 `rand` 和 `srand`

### 泛型编程

> 编写不依赖数据对象类型的代码就是泛型编程。
>
> 最主要技术手段：模板、形式参数化

泛型编程可以解决的问题

1. 函数重载：不需要针对每种类型重写一个相同的函数。在 C 语言中，类似的是**含参宏**，但是它只是进行文本替换，没有类型检查，不能在编译期查找程序错误；并且还要自己关注替换后的代码正确性，要注意运算符优先级。

2. 相似类的定义问题：即类的模板

3. 类型兼容问题：C++ 类型转换形式为 `T(x)`，即单参数构造函数，以及重载类型转换操作符。这种形式不安全，如果没有实现，转换就不存在，而实现上，就要针对 `x` 的类型来实现。

   > 类的继承和多态频繁要求能够通过基类的指针或引用访问派生类的对象

   已有类型转换全是静态转换，不能适应指针或引用的多态性。

   运行期类型信息（RTTI）、转换结果确认（使用异常处理机制）

#### 异常处理机制

异常：程序中更可以被检测的运行不正常的情况。类似的：`if...else...`，`assert`

流程：定义异常类（空类，只需要类的名字） -> 抛出异常 -> 捕获并处理异常 `try...catch...`。`catch (...)` 捕获全部异常。

对于每个自定义异常，精心地设计异常类，便于抛出异常与处理异常，同时便于传递异常信息！并且异常类都应该从标准库中的抽象类中继承下来。

跟 `if...else...` 的区别？

异常再引发：`catch` 中 `throw;`。用于在程序终止前写入日志和实施特殊清除任务。

未处理异常：

异常描述规范：

#### 运行时类型信息

`,`



### Linux 系统编程基础

#### 程序执行环境

参数列表：`int main(int argc, char* argv[]`。`,` 用于解析长选项、短选项，及其参数。

环境变量：如自带的 USER, HOME, PATH 等。Linux 全部的环境变量使用全局变量 `char **environ` 来保存，使用 `getenv("ENV_NAME")` 函数可以返回环境变量的值。

程序退出码：一般是 `main()` 的返回值 `return 0`。但有时程序是提前终止的，这时调用 `exit()` 也会将退出码传给操作系统，参数变量名经常使用 `exit_code`。退出码中 `0` 表示无错误，否则表示有错误，设计退出码并编写帮助手册，有助于用户使用程序。可以通过 `echo $?` 查看上一个程序的退出码。

程序调用的错误处理：主要是系统调用，使用断言或者异常处理机制。宏 `ERRNO` 表达最后一次错误的错误码，`cstring` 中的 `strerror()` 函数用于返回错误码对应的解释信息。

资源管理：在系统调用的过程中必须明确管理的系统资源：内存（确保不泄露）、文件描述符、文件指针、临时文件、同步对象等。资源管理流程：分配资源、正常处理流程、失败时释放资源并退出。

系统日志：

用户日志：

#### 输入输出

标准输入输出流：`cin, cout, cerror`，标准输出流有缓冲，当缓冲区满、程序正常退出、流被刷新或被关闭时，才会输出；而标准错误流没有缓冲。

文件描述符

I/O 函数：

临时文件：

#### 文件系统



#### 设备



#### 库

库可以被单独编译为静态库或动态库。

**静态库**

后缀一般为 `.a`(archives)。将编写的库编译成一系列目标文件 `.o`，再使用 `ar` 命令使用这些目标文件来构造一个单独的静态库。`ar cr libtest.a test1.o test2.o`。链接器搜索静态库时，会把引用了的代码抽取到可执行文件里。再链接库的命令中，静态库的链接应放在命令行的末尾，越放在后面则越容易被解析到，因为程序的代码需求是按命令行从前到后解析的。

**动态库**

后缀一般为 `.so` (shared object)。使用 `g++ -shared -fPIC -o libtest.so test1.o test2.o` 编译动态库。`-fPIC` 表示位置无关代码（Position-Independent Codes），动态库装载到内存后，引用它的都基于库的起始地址，而不是使用真是的物理地址。

编译器先尝试链接动态库，之后才是静态库，因为静态库会导致代码膨胀。如果要强制链接静态库，需要使用 `-static` 选项。

标准库的名称：C 为 `libc`，而 C++ 为 `libstdc++`。但在 Linux 下，并不缺省链接数学库 `libm`，所以需要显示地链接 `-lm`。编译 C++11 程序？Todo

更高层的库链接应写在更前面，交叉相关时应该把前者重写一遍 `g++ -o app app.o -la -lb -la`。

*动态库的使用*

* 隐式调用：在源代码中要包含头文件，并且编译命令中 `-l`，如上面所写。
* 显示调用：不必包含头文件，但需要增加几个系统调用，需要头文件 `,`，编译时增加 `-ldl` 选项。装载与卸载方式如下：Todo

#### makefile



#### 编程实践

第一题，写一段程序代码，通过随机数设备来获取随机数，重新完成我们习题 6.3 和后续习题 7.2。那两道题，是用 C 的 rand() 函数生成的伪随机数，现在我们通过 “/dev/random”、“/dev/urandom”，来获取真正的随机数，重新地来实现我们这两道题。

第二题，要编写一个程序，测试临时文件的读写访问，看看是不是我们所期望的那样进行工作。

第三题，编写一个程序查看 CPU 的信息，包括进程信息，包括它的内核其它的信息　文件　诸如此类，“/proc” 里面的信息你要查询，信息越全越好，因为这道题将会作为我们课程大作业，最终的 Web 服务器的特定的服务。

第四题，为我们第三道题写对应的 makefile，因为这里面我们可能要取很多个信息，甚至有可能我们将写很多个程序，每个程序处理一片信息，所以我们为它写一个 makefile，还是非常非常有必要的，就实现第三道题的 makefile。

### 进程编程

#### 进程基本概念

进程(process)：描述程序过程和资源共享的基本单位（数据格式），为了控制和协调程序的执行。

进程函数：`system, fork, exec, kill, wait, waitpid`

进程组：一个或多个相关联的进程组成，为了进行作业控制。信号可以发送给组中的所有进程。

进程组函数：`getpgid, setpgid`

会话(session)：一个或多个进程组的集合。

会话函数：`getsid, setsid`

#### 信号

信号(signal)：进程通讯机制。发送给进程的特殊异步信号，进程接收到信息时立即处理。Linux 有多种信号，使用数字（宏名）表示。

系统信号：缺省处理逻辑为终止进程，生成内核转储文件。使用 `kill -l` 查看信号列表。

进程间发送信号：终止进程信号 `SITGTERM, SIGKILL`，用户自定义信号 `SIGUSR1, SUGUSR2`。

信号处理：信号处理例程（函数指针）。`sigaction` 函数设置信号配置。

信号结构体 `struct sigaction`：最重要成员为 `sa_handler`。C 语言实现，所以需要传入的是 C 函数。

注意事项：异步操作，当处理信号时，主程序非常脆弱；例程尽量短小，因为可能会被新信号中断；尽量不要 I/O 操作；不要进行复杂的赋值操作，如果需要，则使用 `sig_atomic_t` 类型的全局变量，在外部判断赋值，在 Linux 中等价于 `int`，亦即允许整型和指针赋值。

程序示例：

```c++
#include <signal.h>
#include <iostream>
sig_atomic_t sigusr1_count = 0;
extern "C" {void OnSigUsr1(int signal_number) { ++sigusr1_count; }}
int main(void) {
    std::cout << "pid: " << (int)getpid() << std::endl;
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = &OnSigUsr1;
    sigaction(SIGUSR1, &sa, NULL);
    sleep(100); // 终端输入 kill -s SIGUSR1 pid
    std::cout << "SIGUSR1 counts: " << sigusr1_count << std::endl;
    return 0;
}
```

#### 进程管理

##### 进程创建

`system`：

`fork`：

简单但是不够灵活

`exec`：

##### 进程调度

进程调度策略：

子进程与父进程的情况

`sched.h`：

`sys/time.h`：

`sys/resource.h`：

##### 进程终止

`kill()`：在 `sys/types.h` 和 `signal.h` 中。

`wait()`：

##### 僵尸进程

在类UNIX系统中，**僵尸进程**是指完成执行（通过 `exit` 系统调用，或运行时发生致命错误或收到终止信号所致）但在操作系统的进程表中仍然有一个表项（进程控制块PCB），处于 “终止状态” 的进程。[WikiPedia](https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B)。

##### 子进程异步清除

子进程终止时，自动发送终止信号 SIGCHLD。父进程异步处理这个信号（`wait`）。

##### 守护进程



示例代码：

`daemon()`：

#### 进程间通信

##### 管道



##### 进程信号量



##### 共享内存



##### 映射内存



##### 消息队列



##### 套接字

#### 进程池



### 线程编程

#### 线程基本概念

进程包括多个线程，每个线程有自己的栈，共享进程的堆，也可以使用专有数据。

内核线程：内核支持多线程调度与执行，使用资源较少

轻量级进程：

**用户线程：**映射到轻量级进程，在用户空间创建、同步和销毁，每个线程具有独特的 ID。

线程功能不是 C/C++ 标准库，需要 `-pthread`；是 C++11 标准库，有 `thread` 类和线程同步机制。

*与进程的比较*

+ 线程空间不独立，有问题的线程会相互影响
+ 创建线程性能开销较小
+ 线程用于开发细颗粒度并行性，进程用于开发粗颗粒度并行性
+ 线程容易共享数据

#### 线程管理

##### 线程创建

+ 头文件：`pthread.h`
+ 原型：`int pthread_create( pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void *), void * arg );`

不能依赖线程的先后执行关系，除非自己自己使用线程同步机制。

线程函数参数：传递哑型指针（`void *`），使用 `reinterpret_cast<>()` 转型。但是如果主线程先结束，则子线程无法访问主线程的数据。解决方案为等待子线程结束：`int pthread_join( pthread_t thread, void ** retval );`。

线程函数返回值：主线程必须等待子线程结束，才会有返回值。

##### 线程 ID

+ `int pthread_equal( pthread_t t1, pthread_t t2 );`：判断是否相同
+ `pthread_t pthread_self();`：返回当前线程 ID

##### 线程属性

线程分类

+ 可联线程
+ 分离线程
+ `int pthread_detach( pthread_t thread )` 使分离，但不可逆

示例：

```c++

```

##### 线程撤销

`int pthread_cancel( pthread_t thread );`

线程撤销类型与状态

+ 异步可撤销
+ 延时（同步）可撤销
+ 不可撤销



临界区

##### 线程局部存储(TLS)

让线程拥有数据的独立副本

示例：

```c++

```



##### 线程清除函数



#### 线程同步机制

资源竞争

段错误（Segment Fault）

##### 互斥(mutex, MUTial EXception)

类似二元信号量，一次只有一个线程可以锁定一个数据对象

普通锁、递归锁、检测锁

##### 死锁

资源被竞争占用，且无法释放

处理策略：更改互斥类型

##### 信号量

POSIX 标准信号量：头文件 `semaphore.h`



##### 条件变量



#### C++11 线程库

库：atomic, thread, mutex, condition_variable, future



### 网络编程

套接字函数：`sys/socket.h`

